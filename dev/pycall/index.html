<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Coming from PyCall/PyJulia? · PythonCall &amp; JuliaCall</title><meta name="title" content="Coming from PyCall/PyJulia? · PythonCall &amp; JuliaCall"/><meta property="og:title" content="Coming from PyCall/PyJulia? · PythonCall &amp; JuliaCall"/><meta property="twitter:title" content="Coming from PyCall/PyJulia? · PythonCall &amp; JuliaCall"/><meta name="description" content="Documentation for PythonCall &amp; JuliaCall."/><meta property="og:description" content="Documentation for PythonCall &amp; JuliaCall."/><meta property="twitter:description" content="Documentation for PythonCall &amp; JuliaCall."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall &amp; JuliaCall logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PythonCall &amp; JuliaCall</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">The Julia module PythonCall</span><ul><li><a class="tocitem" href="../pythoncall/">Guide</a></li><li><a class="tocitem" href="../pythoncall-reference/">Reference</a></li></ul></li><li><span class="tocitem">The Python module JuliaCall</span><ul><li><a class="tocitem" href="../juliacall/">Guide</a></li><li><a class="tocitem" href="../juliacall-reference/">Reference</a></li></ul></li><li><span class="tocitem">Conversion</span><ul><li><a class="tocitem" href="../conversion-to-python/">Julia to Python</a></li><li><a class="tocitem" href="../conversion-to-julia/">Python to Julia</a></li></ul></li><li><a class="tocitem" href="../compat/">Compatibility Tools</a></li><li><a class="tocitem" href="../faq/">FAQ &amp; Troubleshooting</a></li><li class="is-active"><a class="tocitem" href>Coming from PyCall/PyJulia?</a><ul class="internal"><li><a class="tocitem" href="#Tips"><span>Tips</span></a></li><li><a class="tocitem" href="#Comparison"><span>Comparison</span></a></li></ul></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Coming from PyCall/PyJulia?</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Coming from PyCall/PyJulia?</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPy/PythonCall.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPy/PythonCall.jl/blob/main/docs/src/pycall.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Coming-from-PyCall/PyJulia?"><a class="docs-heading-anchor" href="#Coming-from-PyCall/PyJulia?">Coming from PyCall/PyJulia?</a><a id="Coming-from-PyCall/PyJulia?-1"></a><a class="docs-heading-anchor-permalink" href="#Coming-from-PyCall/PyJulia?" title="Permalink"></a></h1><p>Another similar interface to Python is provided by <a href="https://github.com/JuliaPy/PyCall.jl">PyCall</a>.</p><p>On this page, we give some tips for migrating between the two modules and a comparison.</p><h2 id="Tips"><a class="docs-heading-anchor" href="#Tips">Tips</a><a id="Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Tips" title="Permalink"></a></h2><ul><li>You can use both PyCall and PythonCall in the same Julia session. This is platform-dependent:<ul><li>On Unix (Linux, Mac, etc.) the Python interpreter used by PythonCall and PyCall must be the same (see below).</li><li>On Windows, it appears to be possible for PythonCall and PyCall to use different interpreters.</li></ul></li><li>To force PythonCall to use the same Python interpreter as PyCall, set the environment variable <code>JULIA_PYTHONCALL_EXE</code> to <code>&quot;@PyCall&quot;</code>. Note that this will opt out of automatic dependency management using CondaPkg.</li><li>Alternatively, to force PyCall to use the same interpreter as PythonCall, set the environment variable <code>PYTHON</code> to <code>PythonCall.python_executable_path()</code> and then <code>Pkg.build(&quot;PyCall&quot;)</code>. You will need to do this each time you change project, because PythonCall by default uses a different Python for each project.</li></ul><h2 id="Comparison"><a class="docs-heading-anchor" href="#Comparison">Comparison</a><a id="Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison" title="Permalink"></a></h2><h3 id="Flexibility-of-conversion"><a class="docs-heading-anchor" href="#Flexibility-of-conversion">Flexibility of conversion</a><a id="Flexibility-of-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Flexibility-of-conversion" title="Permalink"></a></h3><p>In PyCall you do <code>convert(T, x)</code> to convert the Python object <code>x</code> to a Julia <code>T</code>. In PythonCall you similarly do <code>pyconvert(T, x)</code>.</p><p>PythonCall supports far more combinations of types of <code>T</code> and <code>x</code>. For example <code>convert(Vector, x)</code> in PyCall requires <code>x</code> to be a sequence, whereas in PythonCall <code>pyconvert(Vector, x)</code> works if <code>x</code> is an iterable, an object supporting the buffer protocol (such as <code>bytes</code>) or an object supporting the numpy array interface (such as <code>numpy.ndarray</code>).</p><p>Furthermore, <code>pyconvert</code> can be extended to support more types, whereas <code>convert(Vector, x)</code> cannot support more Python types.</p><h3 id="Lossiness-of-conversion"><a class="docs-heading-anchor" href="#Lossiness-of-conversion">Lossiness of conversion</a><a id="Lossiness-of-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Lossiness-of-conversion" title="Permalink"></a></h3><p>Both packages allow conversion of Julia values to Python: <code>PyObject(x)</code> in PyCall, <code>Py(x)</code> in PythonCall.</p><p>Whereas both packages convert numbers, booleans, tuples and strings to their Python counterparts, they differ in handling other types. For example PyCall converts <code>AbstractVector</code> to <code>list</code> whereas PythonCall converts <code>AbstractVector</code> to <code>juliacall.VectorValue</code> which is a sequence type directly wrapping the Julia value - this has the advantage that mutating the Python object also mutates the original Julia object.</p><p>Hence with PyCall the following does not mutate the original array <code>x</code>:</p><pre><code class="language-julia hljs">x = [&quot;foo&quot;, &quot;bar&quot;]
PyObject(x).append(&quot;baz&quot;)
@show x # --&gt; [&quot;foo&quot;, &quot;bar&quot;]</code></pre><p>whereas with PythonCall the following does mutate <code>x</code>:</p><pre><code class="language-julia hljs">x = [&quot;foo&quot;, &quot;bar&quot;]
Py(x).append(&quot;baz&quot;)
@show x # --&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</code></pre><p>In fact, PythonCall has the policy that any mutable object will by default be wrapped in this way, which not only preserves mutability but makes conversion faster for large containers since it does not require taking a copy of all the data.</p><h3 id="Automatic-conversion"><a class="docs-heading-anchor" href="#Automatic-conversion">Automatic conversion</a><a id="Automatic-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-conversion" title="Permalink"></a></h3><p>In PyCall, most function calls, attribute accesses, indexing, etc. of Python object by default automatically convert their result to a Julia object. This means that the following</p><pre><code class="language-julia hljs">pyimport(&quot;sys&quot;).modules[&quot;KEY&quot;] = &quot;VALUE&quot;</code></pre><p>does not actually modify the modules dict because it was <em>copied</em> to a new Julia <code>Dict</code>. This was probably not intended, plus it wasted time copying the whole dictionary. Instead you must do</p><pre><code class="language-julia hljs">set!(pyimport(os).&quot;environ&quot;, &quot;KEY&quot;, &quot;VALUE&quot;)</code></pre><p>In PythonCall, we don&#39;t do any such automatic conversion: we always return <code>Py</code>. This means that the first piece of code above does what you think.</p><h3 id="Which-Python"><a class="docs-heading-anchor" href="#Which-Python">Which Python</a><a id="Which-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Which-Python" title="Permalink"></a></h3><p>PyCall uses some global installation of Python - typically the version of Python installed on the system or used by Conda.</p><p>PythonCall uses a separate Conda environment for each Julia environment/project/package and installs Python (and other Python packages) into that. This means that different Julia projects can maintain an isolated set of Python dependencies (including the Python version itself).</p><h3 id="Corresponding-Python-packages"><a class="docs-heading-anchor" href="#Corresponding-Python-packages">Corresponding Python packages</a><a id="Corresponding-Python-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Corresponding-Python-packages" title="Permalink"></a></h3><p>PyCall has the corresponding Python package <a href="https://github.com/JuliaPy/pyjulia">PyJulia</a> for calling Julia from Python, and PythonCall similarly has JuliaCall.</p><p>One difference is between them is their code size: PyJulia is a large package, whereas JuliaCall is very small, with most of the implementation being in PythonCall itself. The practical up-shot is that PythonCall/JuliaCall have very symmetric interfaces; for example they use identical conversion policies and have the same set of wrapper types available.</p><p>Note also that JuliaCall will use a separate Julia project for each virtual/conda environment. This means that different Python environments can maintain an isolated set of Julia dependencies, including the versions of Julia and PythonCall themselves.</p><h3 id="Compatibility"><a class="docs-heading-anchor" href="#Compatibility">Compatibility</a><a id="Compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility" title="Permalink"></a></h3><p>PyCall supports Julia 0.7+ and Python 2.7+, whereas PythonCall supports Julia 1.6.1+ and Python 3.7+. PyCall requires numpy to be installed, PythonCall doesn&#39;t (it provides the same fast array access through the buffer protocol and array interface).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« FAQ &amp; Troubleshooting</a><a class="docs-footer-nextpage" href="../releasenotes/">Release Notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 31 January 2024 22:04">Wednesday 31 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
